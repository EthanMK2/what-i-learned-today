# Simple Problems Need Simple Solutions, and Complex Problems Need Simple Solutions.

I hadn't really taken it to heart when I heard the phrase "plan out the code, then make the code" until I ran into many logical problems when making my calculator page in the contract manager app I've been working on. You can personally see this code in my commit history on the prototype-contract-manager on June 12, 2023. I was messing with all sorts of react states, previous states, and I even got to the point of thinking of using a closure. It was a bunch of complex logic for a rather moderately complex problem: performing calculations based on user inputs. I made all these functions to react to the user when they entered a number, a decimal point, or an operation. This only got progressively worse as I threw in the "display string" that tried to show previous entered information. I ended up getting very confused and annoyed at the fact that this was taking much longer than anticipated. After all, I made a calculator before in vanilla javascript, and that only took a few hours from scratch. So, I thought that this problem would be no different. I would just hope into the code, and start working. But, I did not think the solution through. Not even think it through in terms of React. I got to the point where I just decided to completely rethink the logic of how a calculator works.

The solution I came up with was to simply have the user enter characters in a long string, then I analyze that string. I also would prevent the user from entering bug-prone strings of characters, such as entering an operation twice or more, or a decimal character more than once on the same number. Then I pass the string to a loop everytime a number is entered to show the result. Entering "equals" will set the long string of characters equal to the result of that string. State in the loop is managed in local loop variables instead of react state, since the result is what we are interested in anyway. There's a few more details and nuance, but that is the gist of it. I could not even explain the previous code that I wrote, because I made that fatal mistake of underestimating the problem, and coding while/before I thought of a solution. It just became a case of plugging holes as they appeared on a boat, but not actually solving the underlying logical issues. Now I know what programmers mean by "plan first, then code later", because I learned it the hard way. 
